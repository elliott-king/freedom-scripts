import boto3
import os

from collections import defaultdict

from freedom.events.models import Event, BaseModel

# Updating items after a full table scan.
# table.update_item(Key={'id': item['id']}, UpdateExpression='set permanent = :r', ExpressionAttributeValues={':r': 'true'})  # noqa: E501

# Tables autogenerated by Amplify Api
# DEV_ART_TABLE = os.environ['DYNAMODB_ART_TABLE']
DEV_EVENTS_TABLE = os.environ["DYNAMODB_EVENT_TABLE"]
DEV_PHOTOS_TABLE = os.environ["DYNAMODB_EVENTPHOTOS_TABLE"]
REGION = os.environ["DYNAMODB_REGION"]


def delete_table(table_name):
    dynamodb = boto3.resource("dynamodb", region_name=REGION)
    table = dynamodb.Table(table_name)
    print(table.delete())


def create_table(table_name, key_column="id"):
    dynamodb = boto3.resource("dynamodb", region_name=REGION)
    session = boto3.session.Session()
    client = session.client("dynamodb", region_name=REGION)
    client.get_waiter("table_not_exists").wait(TableName=table_name)
    print("creating table")

    # TODO: add sort key: 'name'
    table = dynamodb.create_table(
        TableName=table_name,
        KeySchema=[{"AttributeName": key_column, "KeyType": "HASH"}],
        AttributeDefinitions=[{"AttributeName": key_column, "AttributeType": "S"}],
        ProvisionedThroughput={"WriteCapacityUnits": 5, "ReadCapacityUnits": 5},
    )

    print("New table:", table_name, "with", table.item_count, "items.")


def get_all_items_from_table(table_name):
    dynamodb = boto3.resource("dynamodb", region_name=REGION)
    table = dynamodb.Table(table_name)
    print(f"getting items from table {table}")

    response = table.scan()
    return response["Items"]


def delete_item(item, table_name):
    dynamodb = boto3.resource("dynamodb", region_name=REGION)
    table = dynamodb.Table(table_name)

    table.delete_item(Key={"id": item["id"]})


PAIRS = {}


# TODO: should correspond to list for each event
# fixme: I no longer know what this does
def load_duplicates():
    PAIRS[DEV_EVENTS_TABLE] = defaultdict(list)
    for e in get_all_items_from_table(DEV_EVENTS_TABLE):
        name = e["name"].lower().strip()
        PAIRS[DEV_EVENTS_TABLE][name].append(
            {"dates": set(e["dates"]), "host": e.get("host", None)}
        )

    # PAIRS[DEV_ART_TABLE] = defaultdict(str)
    # for e in get_all_items_from_table(DEV_ART_TABLE):
    #     name = e['name'].lower().strip()
    #     PAIRS[DEV_ART_TABLE][name] = e['type']


load_duplicates()


# TODO: handle public arts as well
def is_uploaded(location: BaseModel, table=DEV_EVENTS_TABLE):
    pairs = PAIRS[table]

    name = location.name.lower().strip()
    if name in pairs:
        if table == DEV_EVENTS_TABLE:
            return location.is_ddb_uploaded(pairs)
        # if table == DEV_ART_TABLE:
        #     if location['type'] == pairs[name]['type']:
        #         return True
    return False


def add_items_to_table(table_name: str, photo_table_name: str, items: list[Event]):
    dynamodb = boto3.resource("dynamodb", region_name=REGION)

    table = dynamodb.Table(table_name)
    # photos_table = dynamodb.Table(photo_table_name)

    for index, e in enumerate(items):
        if is_uploaded(e, table_name):
            print('Cannot add: "' + e["name"] + '" already exists in dynamodb')
            continue

        try:
            if not e.finalized:
                e.finalize()
        except ValueError as err:
            print(err)
            continue

        print("Adding location", index, "- ", e.name)
        response = table.put_item(Item=e.to_dict(for_dynamodb=True))
        code = response["ResponseMetadata"]["HTTPStatusCode"]
        if code != 200:
            print("table put_item error:", code)

        # photo = legacy_support.update_legacy_photo(e)
        # photos = e.pop('photos', None)
        # if photo:
        #     response = photos_table.put_item(Item=photo)
        #     print('Photo    HTTP code', response['ResponseMetadata']['HTTPStatusCode'])
        #     e['photos'] = photos # seems unnecessary
